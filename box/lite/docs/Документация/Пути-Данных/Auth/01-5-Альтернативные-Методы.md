# Поддиаграмма 5: Альтернативные методы аутентификации

## Объяснение терминов

**Bearer Token Authentication** - метод аутентификации через HTTP заголовок Authorization с Bearer токеном, используемый для API интеграций и прямого доступа к Hugging Face API.

**Admin Token Management** - система управления административными токенами для предоставления специальных прав доступа к системным функциям и администрированию.

**Token Caching** - кэширование токенов в базе данных для повышения производительности и избежания повторных запросов к внешним API.

**Settings Synchronization** - синхронизация настроек пользователя между клиентом и сервером с использованием debouncing для оптимизации производительности.

**Debounced Updates** - техника задержки обновлений на сервере для группировки множественных изменений настроек в один запрос.

**Trusted Header Authentication** - аутентификация через доверенные HTTP заголовки, обычно используемая в корпоративных средах с прокси-серверами.

## Визуальная диаграмма

```mermaid
graph TB
    subgraph "Клиент (Браузер)"
        C[Browser App]
        D[Settings Store]
    end
    
    subgraph "Бекенд (SvelteKit)"
        G[auth.ts]
        I[adminToken.ts]
        J[API Endpoint]
        K[userGroup API]
    end
    
    subgraph "База данных (MongoDB)"
        M[tokenCaches Collection]
        N[settings Collection]
    end
    
    subgraph "Внешние сервисы"
        O[HF API]
    end
    
    %% Bearer Token Authentication
    C -->|28 - Bearer Token| G
    G -->|29 - Проверка токена| O
    G -->|30 - Кэширование токена| M
    
    %% Admin Token Authentication
    C -->|31 - Admin Token| I
    I -->|32 - Проверка админ прав| G
    
    %% Настройки пользователя
    C -->|33 - Изменение настроек| D
    D -->|34 - Debounced Update| K
    K -->|35 - Сохранение в БД| N
    
    %% Trusted Header Authentication
    C -->|36 - Trusted Header| G
    G -->|37 - Email из заголовка| G
```

## Передаваемые данные (JSON)

### **Шаг 28: Bearer Token Authentication**

**Действие:** Клиент отправляет API запрос с Bearer токеном в заголовке Authorization для аутентификации через Hugging Face API.

**Тип данных:** HTTP запрос с заголовком Authorization, содержащим Bearer токен Hugging Face.

**Результат:** Сервер получает токен и может аутентифицировать пользователя через Hugging Face API или кэш токенов.

**HTTP запрос с Bearer токеном:**
```json
{
  "method": "POST",                                       // HTTP метод
  "url": "/api/v2/conversation",                          // API endpoint
  "headers": {
    "Authorization": "Bearer hf_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", // Bearer токен Hugging Face
    "Content-Type": "application/json"                    // Тип контента
  },
  "body": {
    "message": "Hello, how are you?",                     // Сообщение пользователя
    "conversationId": "conversation_id_here"              // ID разговора
  }
}
```

### **Шаг 29: Проверка Bearer Token через HF API**

**Действие:** При отсутствии кэша система отправляет запрос к Hugging Face API для валидации Bearer токена и получения данных пользователя.

**Тип данных:** HTTP запрос к Hugging Face API с Bearer токеном в заголовке Authorization.

**Результат:** Получены данные пользователя от Hugging Face API для аутентификации и создания/обновления профиля в системе.

**Пример кода из src/lib/server/auth.ts (строки 274-276):**
```typescript
// src/lib/server/auth.ts
const response = await fetch("https://huggingface.co/api/whoami-v2", {
	headers: { Authorization: `Bearer ${token}` },        // Bearer токен в заголовке
});

if (!response.ok) {
	throw new Error("Unauthorized");                      // Ошибка аутентификации
}

const data = await response.json();                      // Данные пользователя от HF API
```

**HTTP запрос к Hugging Face API:**
```json
{
  "method": "GET",                                        // HTTP метод
  "url": "https://huggingface.co/api/whoami-v2",         // Hugging Face API endpoint
  "headers": {
    "Authorization": "Bearer hf_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" // Bearer токен
  }
}
```

### **Шаг 30: Кэширование токена**

**Действие:** После успешной валидации токена система кэширует его в базе данных для повышения производительности последующих запросов.

**Тип данных:** MongoDB операция insertOne для создания документа кэша токена в коллекции tokenCaches.

**Результат:** Токен сохранен в кэше, что позволяет избежать повторных запросов к Hugging Face API для того же токена.

**Пример кода из src/lib/server/auth.ts (строки 288-293):**
```typescript
// src/lib/server/auth.ts
await collections.tokenCaches.insertOne({
	tokenHash: hash,                                      // Хэш токена для поиска
	userId: data.id,                                      // ID пользователя от HF API
	createdAt: new Date(),                                // Дата создания кэша
	updatedAt: new Date(),                                // Дата обновления кэша
});
```

**MongoDB операция:**
```json
{
  "collection": "tokenCaches",                            // Коллекция кэша токенов
  "operation": "insertOne",                               // Создание нового документа
  "document": {
    "_id": "token_cache_object_id",                       // Уникальный ID документа
    "tokenHash": "hashed_token_value",                    // Хэш токена для поиска
    "userId": "user_id_from_hf",                          // ID пользователя от Hugging Face
    "createdAt": "2024-01-01T12:00:00Z",                 // Дата создания кэша
    "updatedAt": "2024-01-01T12:00:00Z"                  // Дата обновления кэша
  }
}
```

### **Шаг 31: Admin Token Authentication**

**Действие:** Клиент отправляет запрос с административным токеном для получения специальных прав доступа к системным функциям.

**Тип данных:** HTTP запрос с административным токеном в заголовке Authorization или URL параметре.

**Результат:** Система проверяет административный токен и предоставляет специальные права доступа.

**HTTP запрос с Admin токеном:**
```json
{
  "method": "POST",                                       // HTTP метод
  "url": "/api/admin/stats",                              // Административный API endpoint
  "headers": {
    "Authorization": "Bearer admin_token_here",           // Административный токен
    "Content-Type": "application/json"                    // Тип контента
  },
  "body": {
    "action": "get_stats"                                 // Административное действие
  }
}
```

### **Шаг 32: Проверка Admin Token**

**Действие:** Система проверяет административный токен и предоставляет специальные права доступа к системным функциям.

**Тип данных:** Функция проверки токена, которая валидирует административные права и управляет сессиями администраторов.

**Результат:** Пользователь получает административные права и может выполнять системные операции.

**Пример кода из src/lib/server/adminToken.ts (строки 20-30):**
```typescript
// src/lib/server/adminToken.ts
public checkToken(token: string, sessionId: Session["sessionId"]) {  // Функция проверки административного токена
	if (!this.enabled) return false;  // Проверка включения функции административных токенов
	if (token === this.token) {  // Сравнение с текущим административным токеном
		logger.info(`[ADMIN] Token validated`);  // Логирование успешной валидации
		this.adminSessions.push(sessionId);  // Добавление сессии в список администраторов
		this.token = config.ADMIN_TOKEN || v4();  // Генерация нового токена (ротация)
		return true;  // Возврат успешного результата
	}

	return false;  // Токен невалиден
}
```

**Вызов функции:**
```json
{
  "function": "checkToken",                               // Название функции
  "parameters": {
    "token": "admin_token_here",                          // Административный токен
    "sessionId": "session_id_here"                        // ID сессии пользователя
  },
  "returns": {
    "valid": true,                                        // Результат валидации
    "isAdmin": true,                                      // Права администратора
    "permissions": ["read", "write", "admin"]             // Список разрешений
  }
}
```

### **Шаг 33: Изменение настроек**

**Действие:** Пользователь изменяет настройки в интерфейсе приложения, что инициирует процесс синхронизации с сервером.

**Тип данных:** Обновление Svelte store с новыми настройками пользователя.

**Результат:** Настройки обновлены локально и запланирована синхронизация с сервером через debounced обновление.

**Пример кода из src/lib/stores/settings.ts (строки 36-71):**
```typescript
// src/lib/stores/settings.ts
async function setSettings(settings: Partial<SettingsStore>) {  // Функция обновления настроек
	baseStore.update((s) => ({  // Обновление локального store
		...s,
		...settings,  // Применение новых настроек
	}));

	if (browser) {  // Проверка браузерного окружения
		clearTimeout(timeoutId);  // Очистка предыдущего таймера
		timeoutId = setTimeout(async () => {  // Установка нового таймера для debounced обновления
			await fetch(`${base}/settings`, {  // Отправка настроек на сервер
				method: "POST",  // HTTP метод POST
				headers: {
					"Content-Type": "application/json",  // Тип контента JSON
				},
				body: JSON.stringify({  // Сериализация настроек
					...get(baseStore),  // Текущие настройки из store
					...settings,  // Новые настройки
				}),
			});

			invalidate(UrlDependency.ConversationList);  // Инвалидация кэша списка разговоров
			// set savedRecently to true for 3s
			baseStore.update((s) => ({  // Установка флага недавнего сохранения
				...s,
				recentlySaved: true,  // Флаг успешного сохранения
			}));
			setTimeout(() => {  // Сброс флага через 3 секунды
				baseStore.update((s) => ({
					...s,
					recentlySaved: false,  // Сброс флага
				}));
			}, 3000);
		}, 300);  // Задержка 300ms для debouncing
		// debounce server calls by 300ms
	}
}
```

**Обновление настроек:**
```json
{
  "settings": {
    "shareConversationsWithModelAuthors": true,            // Разрешение делиться разговорами
    "hideEmojiOnSidebar": false,                           // Скрытие эмодзи в боковой панели
    "activeModel": "claude-3-sonnet",                      // Активная модель
    "customPrompts": {                                     // Пользовательские промпты
      "custom1": "You are a helpful assistant"
    },
    "tools": ["tool1", "tool2"],                           // Выбранные инструменты
    "disableStream": false,                                // Отключение потокового вывода
    "directPaste": true                                    // Прямая вставка
  }
}
```

### **Шаг 34: Debounced Update**

**Действие:** Система использует debouncing для группировки множественных изменений настроек в один запрос к серверу.

**Тип данных:** HTTP POST запрос к API настроек с задержкой 300ms для оптимизации производительности.

**Результат:** Настройки отправлены на сервер одним запросом, что снижает нагрузку и улучшает производительность.

**Пример кода из src/lib/stores/settings.ts (строки 44-69):**
```typescript
// src/lib/stores/settings.ts
timeoutId = setTimeout(async () => {  // Debounced обновление настроек
	await fetch(`${base}/settings`, {  // HTTP запрос к API настроек
		method: "POST",  // HTTP метод POST
		headers: {
			"Content-Type": "application/json",  // Тип контента JSON
		},
		body: JSON.stringify({  // Сериализация настроек в JSON
			...get(baseStore),  // Текущие настройки из store
			...settings,  // Новые настройки
		}),
	});

	invalidate(UrlDependency.ConversationList);  // Инвалидация кэша списка разговоров
	// set savedRecently to true for 3s
	baseStore.update((s) => ({  // Установка флага недавнего сохранения
		...s,
		recentlySaved: true,  // Флаг успешного сохранения
	}));
	setTimeout(() => {  // Сброс флага через 3 секунды
		baseStore.update((s) => ({
			...s,
			recentlySaved: false,  // Сброс флага
		}));
	}, 3000);
}, 300);  // Задержка 300ms для debouncing
// debounce server calls by 300ms
```

**HTTP запрос к API настроек:**
```json
{
  "method": "POST",                                        // HTTP метод
  "url": "/api/v2/user/settings",                          // API endpoint настроек
  "headers": {
    "Content-Type": "application/json",                    // Тип контента
    "Cookie": "session=encrypted_session_id"               // Cookie сессии
  },
  "body": {
    "shareConversationsWithModelAuthors": true,            // Настройки пользователя
    "hideEmojiOnSidebar": false,
    "activeModel": "claude-3-sonnet",
    "customPrompts": {
      "custom1": "You are a helpful assistant"
    },
    "tools": ["tool1", "tool2"],
    "disableStream": false,
    "directPaste": true
  }
}
```

### **Шаг 35: Сохранение в БД**

**Действие:** Сервер сохраняет настройки пользователя в базе данных с использованием upsert операции.

**Тип данных:** MongoDB операция updateOne с upsert для создания или обновления настроек пользователя.

**Результат:** Настройки сохранены в базе данных и будут доступны при следующих сессиях пользователя.

**Пример кода из src/lib/server/api/routes/groups/user.ts (строки 123-138):**
```typescript
// src/lib/server/api/routes/groups/user.ts
await collections.settings.updateOne(  // Обновление настроек пользователя
	authCondition(locals),  // Условие аутентификации (userId или sessionId)
	{
		$set: {  // Поля для обновления
			...settings,  // Новые настройки
			...(ethicsModalAccepted && { ethicsModalAcceptedAt: new Date() }),  // Дата принятия этики (если принята)
			updatedAt: new Date(),  // Дата обновления
		},
		$setOnInsert: {  // Поля только при создании документа
			createdAt: new Date(),  // Дата создания
		},
	},
	{
		upsert: true,  // Создать документ если не существует
	}
);
```

**MongoDB операция:**
```json
{
  "collection": "settings",                                // Коллекция настроек
  "operation": "updateOne",                                // Обновление одного документа
  "query": {
    "userId": "user_object_id"                             // ID пользователя
  },
  "update": {
    "$set": {                                              // Обновление полей
      "shareConversationsWithModelAuthors": true,          // Настройки пользователя
      "hideEmojiOnSidebar": false,
      "activeModel": "claude-3-sonnet",
      "customPrompts": {
        "custom1": "You are a helpful assistant"
      },
      "tools": ["tool1", "tool2"],
      "disableStream": false,
      "directPaste": true,
      "updatedAt": "2024-01-01T12:00:00Z"                 // Дата обновления
    },
    "$setOnInsert": {                                      // Поля только при создании
      "createdAt": "2024-01-01T12:00:00Z"                 // Дата создания
    }
  },
  "options": {
    "upsert": true                                         // Создать если не существует
  }
}
```

### **Шаг 36: Trusted Header Authentication**

**Действие:** Система проверяет доверенные HTTP заголовки для аутентификации в корпоративных средах с прокси-серверами.

**Тип данных:** HTTP заголовок с email пользователя, установленный доверенным прокси-сервером.

**Результат:** Пользователь аутентифицирован через доверенный заголовок без необходимости OIDC или Bearer токена.

**Пример кода из src/lib/server/auth.ts (строки 207-214):**
```typescript
// src/lib/server/auth.ts
let email = null;  // Переменная для хранения email из заголовка
if (config.TRUSTED_EMAIL_HEADER) {  // Проверка настройки доверенного заголовка
	if (headers.type === "elysia") {  // Проверка типа заголовков (Elysia)
		email = headers.value[config.TRUSTED_EMAIL_HEADER];  // Извлечение email из Elysia заголовков
	} else {  // SvelteKit заголовки
		email = headers.value.get(config.TRUSTED_EMAIL_HEADER);  // Извлечение email из SvelteKit заголовков
	}
}
```

**HTTP заголовок:**
```json
{
  "headers": {
    "X-Forwarded-Email": "user@company.com",               // Доверенный email заголовок
    "X-Forwarded-User": "username",                        // Доверенный пользователь
    "X-Forwarded-For": "192.168.1.100"                    // IP адрес
  }
}
```

### **Шаг 37: Email из заголовка**

**Действие:** Система создает пользователя на основе email из доверенного заголовка для корпоративной аутентификации.

**Тип данных:** Создание пользователя с данными из доверенного заголовка и установка специальных флагов.

**Результат:** Пользователь аутентифицирован через корпоративную систему без необходимости внешней аутентификации.

**Пример кода из src/lib/server/auth.ts (строки 219-236):**
```typescript
// src/lib/server/auth.ts
if (email) {  // Если email найден в доверенном заголовке
	secretSessionId = sessionId = await sha256(email);  // Хэширование email для session ID
	return {
		user: {  // Создание пользователя из email
			_id: new ObjectId(sessionId.slice(0, 24)),  // Создание ObjectId из хэша
			name: email,  // Имя = email
			email,  // Email из заголовка
			createdAt: new Date(),  // Дата создания
			updatedAt: new Date(),  // Дата обновления
			hfUserId: email,  // HF ID = email
			avatarUrl: "",  // Пустой аватар
			logoutDisabled: true,  // Отключение выхода (корпоративная аутентификация)
		},
		sessionId,  // Хэшированный session ID
		secretSessionId,  // Секретный session ID
		isAdmin: adminTokenManager.isAdmin(sessionId),  // Проверка админ прав
	};
}
```

**Создание пользователя:**
```json
{
  "user": {
    "_id": "user_object_id_from_hash",                     // ID из хэша email
    "name": "user@company.com",                            // Имя = email
    "email": "user@company.com",                           // Email из заголовка
    "createdAt": "2024-01-01T12:00:00Z",                  // Дата создания
    "updatedAt": "2024-01-01T12:00:00Z",                  // Дата обновления
    "hfUserId": "user@company.com",                        // HF ID = email
    "avatarUrl": "",                                       // Пустой аватар
    "logoutDisabled": true                                 // Отключение выхода
  },
  "sessionId": "hashed_email_session_id",                  // Хэшированный sessionId
  "secretSessionId": "hashed_email_session_id",            // Секретный sessionId
  "isAdmin": false                                         // Права администратора
}
```

## Описание блоков

### **Browser App**

**Что это:** Основное клиентское приложение SvelteKit - браузерное приложение, которое взаимодействует с сервером

**Задача:** Отправлять различные типы запросов (Bearer токены, Admin токены), управлять настройками пользователя и обеспечивать взаимодействие с системой

**Файлы проекта:** 
- src/routes/+layout.svelte - основной layout приложения
- src/routes/+page.svelte - главная страница приложения

**Ключевые функции:**
- Отправка API запросов с Bearer токенами
- Использование административных токенов для системных операций
- Управление настройками пользователя
- Взаимодействие с различными методами аутентификации
- Отображение интерфейса приложения

### **Settings Store**

**Что это:** Svelte store для управления настройками пользователя - реактивное хранилище состояния настроек

**Задача:** Хранить настройки локально, синхронизировать с сервером через debounced обновления и обеспечивать реактивность интерфейса

**Файлы проекта:** 
- src/lib/stores/settings.ts - основной store настроек

**Ключевые функции:**
- Локальное хранение настроек пользователя
- Debounced синхронизация с сервером (300ms задержка)
- Реактивные обновления интерфейса
- Управление флагом recentlySaved (3 секунды)
- Инвалидация кэша при обновлениях
- Поддержка instantSet для немедленного сохранения

### **auth.ts**

**Что это:** Основной модуль аутентификации - центральный модуль для работы с различными методами аутентификации

**Задача:** Поддерживать множественные методы аутентификации (Bearer токены, trusted headers, session-based), кэшировать токены и управлять правами доступа

**Файлы проекта:** 
- src/lib/server/auth.ts

**Ключевые функции:**
- `authenticateRequest()` - основная функция аутентификации
- Поддержка Bearer token аутентификации с кэшированием
- Поддержка trusted header аутентификации
- Кэширование токенов для производительности
- Интеграция с Hugging Face API для валидации токенов
- Управление правами администратора
- Поддержка Elysia и SvelteKit типов запросов

### **adminToken.ts**

**Что это:** Модуль для управления административными токенами - система для предоставления специальных прав доступа

**Задача:** Проверять административные токены, управлять сессиями администраторов и предоставлять специальные права доступа к системным функциям

**Файлы проекта:** 
- src/lib/server/adminToken.ts

**Ключевые функции:**
- `checkToken()` - валидация административных токенов
- `isAdmin()` - проверка административных прав
- `removeSession()` - удаление административных сессий
- `displayToken()` - отображение токена для входа
- Управление списком административных сессий
- Автоматическая ротация токенов

### **userGroup API**

**Что это:** Elysia API группа для пользовательских операций - серверные обработчики для управления настройками и профилем пользователя

**Задача:** Обрабатывать запросы на обновление настроек, валидировать данные и сохранять их в базе данных

**Файлы проекта:** 
- src/lib/server/api/routes/groups/user.ts

**Ключевые функции:**
- POST /user/settings - обновление настроек пользователя
- Валидация настроек через zod схемы
- Upsert операции в базе данных
- Проверка существования инструментов
- Обработка этических соглашений

### **API Endpoint**

**Что это:** Общий API endpoint для авторизованных запросов - серверные обработчики для различных API функций

**Задача:** Обрабатывать API запросы, проверять авторизацию через locals, возвращать данные с учетом прав пользователя

**Файлы проекта:** 
- src/routes/api/*/+server.ts - различные API endpoints
- src/routes/api/user/+server.ts - пользовательские API
- src/routes/api/conversation/[id]/+server.ts - API разговоров
- src/routes/api/tools/+server.ts - API инструментов

**Ключевые функции:**
- Обработка HTTP запросов (GET, POST, PATCH, DELETE)
- Проверка авторизации через locals.user
- Валидация входных данных
- Выполнение бизнес-логики
- Возврат JSON ответов
- Обработка ошибок и исключений

### **tokenCaches Collection**

**Что это:** MongoDB коллекция для кэширования токенов - коллекция для хранения кэшированных Bearer токенов

**Задача:** Кэшировать Bearer токены для повышения производительности и избежания повторных запросов к Hugging Face API

**Файлы проекта:** 
- src/lib/server/database.ts (строки 132, 151) - определение коллекции
- src/lib/types/TokenCache.ts - типы данных кэша токенов

**Ключевые функции:**
- Кэширование Bearer токенов от Hugging Face
- Связь токенов с пользователями через userId
- Отслеживание времени создания и обновления
- Повышение производительности API запросов
- Сокращение нагрузки на внешние API

### **settings Collection**

**Что это:** MongoDB коллекция для хранения настроек пользователей - коллекция для персистентного хранения пользовательских настроек

**Задача:** Хранить настройки пользователей, их предпочтения и конфигурации для обеспечения персонализированного опыта

**Файлы проекта:** 
- src/lib/server/database.ts (строки 128, 147) - определение коллекции
- src/lib/types/Settings.ts - типы данных настроек

**Ключевые функции:**
- Хранение пользовательских настроек (тема, модель, инструменты)
- Управление пользовательскими промптами
- Отслеживание этических соглашений
- Поддержка upsert операций
- Связь с пользователями через userId

### **Hugging Face API**

**Что это:** Внешний API Hugging Face - сервис для валидации токенов и получения данных пользователей

**Задача:** Валидировать Bearer токены и предоставлять актуальные данные пользователей для аутентификации

**Файлы проекта:** 
- src/lib/server/auth.ts (строки 274-276) - API вызовы
- .env.local - переменные окружения для API

**Ключевые функции:**
- Валидация Bearer токенов через /api/whoami-v2 endpoint
- Предоставление данных пользователей (ID, имя, email, аватар)
- Информация об организациях пользователя
- Поддержка OAuth токенов Hugging Face

## Сводка этапа

**Цель:** Предоставить альтернативные способы аутентификации и управления настройками для различных сценариев использования

**Результат:** Пользователи могут аутентифицироваться через Bearer токены, Admin токены, trusted headers и эффективно синхронизировать настройки с сервером

**Ключевые моменты:** 
- **Bearer Token Authentication** - прямая аутентификация через Hugging Face API с кэшированием токенов для повышения производительности
- **Admin Token Management** - специальные права администратора для системных операций с автоматической ротацией токенов
- **Settings Synchronization** - локальное хранение настроек с debounced синхронизацией на сервер (300ms задержка) для оптимизации производительности
- **Token Caching** - кэширование Bearer токенов в базе данных для избежания повторных запросов к внешним API
- **Trusted Header Authentication** - корпоративная аутентификация через доверенные HTTP заголовки для интеграции с корпоративными прокси-серверами
- **Debounced Updates** - группировка множественных изменений настроек в один запрос для снижения нагрузки на сервер
- **Upsert Operations** - создание или обновление настроек пользователя в базе данных с поддержкой атомарных операций
- **Reactive State Management** - реактивное управление состоянием настроек с автоматической синхронизацией и инвалидацией кэша
- **Multi-method Authentication** - поддержка множественных методов аутентификации в единой системе для гибкости развертывания
